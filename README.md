# Zscripts

Zscripts is a framework-agnostic utility for aggregating source files into
navigable logs. The toolchain helps multi-stack teams surface Python, JavaScript,
TypeScript, CSS, shell scripts, infrastructure YAML, and other assets in a
consistent format so they can audit or ship documentation more quickly.

The repository ships with a configurable command line interface, templates for
regenerating this README, and a sample project that mixes backend, frontend, and
infrastructure code to highlight cross-stack coverage.

## Repository Layout

- **sample_project/** – Mixed-language reference project that demonstrates how
  the scanners traverse Python, JavaScript, shell, and YAML sources.
- **zscripts/** – Python package containing the CLI, configuration loader, and
  supporting utilities.
- **zscripts.config.json** – Default configuration file consumed by the CLI and
  helper modules.
- **README.md** – Autogenerated documentation (built from files within
  `zscripts/zreadme/`).

## Configuration

The runtime configuration now lives in a standalone JSON document instead of a
Python module. By default, `python -m zscripts` loads `zscripts.config.json` from
the repository root. The schema is intentionally simple so it can be tracked in
source control or generated dynamically:

```jsonc
{
  "skip": ["node_modules", "venv", "dist"],
  "file_types": {
    "models.py": "models_files",
    "views.py": "views_files"
  },
  "directories": {
    "log_root": "logs",
    "build": "build_files",
    "analysis": "analysis_logs",
    "consolidation": "consoli_files",
    "work": "logs_files"
  },
  "collection_logs": {
    "python": "logs_apps_pyth",
    "all": "logs_apps_all"
  },
  "single_targets": {
    "python": "capture_all_pyth.txt",
    "any": "capture_all.txt"
  }
}
```

Every path is resolved relative to the `zscripts/` package directory, so the
example above stores aggregated logs under `zscripts/logs/`. You can provide a
custom configuration file via the `--config` flag on any CLI command. The module
`zscripts.config` exposes helpers (`load_config`, `get_config`, and constants such
as `LOG_DIR`) for scripts that want to introspect the parsed settings.

## CLI Workflow

The CLI bundles the most common automation routines under `python -m zscripts`.
Each command respects the configuration file described above.

```text
usage: python -m zscripts [-h] [--config CONFIG] [--project-root PROJECT_ROOT] {collect,consolidate,tree} ...
```

All subcommands share `--dry-run` and `--verbose` switches. `--dry-run` previews
the files that would be written without touching the filesystem. `--verbose`
escalates logging to `INFO` level for easier troubleshooting.

### `collect`

Generate per-directory logs for one or more stacks. The command accepts a
comma-separated list of stacks (`python`, `html`, `css`, `js`, `python_html`, or
`all`). The JavaScript bucket scans modern variants out of the box:

- `js` – `.js`, `.jsx`, `.mjs`, `.cjs`, `.ts`, `.tsx`, `.mts`, `.cts`

```bash
python -m zscripts collect --types python,js --project-root sample_project
```

Logs are written to the directories declared in `collection_logs`.
Use `--dry-run` to preview the grouped files without creating any logs:

```bash
python -m zscripts collect --types python --project-root sample_project --dry-run
```

### `consolidate`

Create a single file that merges all sources for the requested stack.

```bash
python -m zscripts consolidate --types python --output /tmp/project-python.txt
```

When no output file is supplied, the command falls back to the
`single_targets` configuration entry. Combine `--dry-run` with either the
default target or a custom `--output` path to inspect the ordered file list
before writing:

```bash
python -m zscripts consolidate --types python --project-root sample_project --dry-run
```

### `tree`

Snapshot the repository structure. File contents are omitted by default to
produce a compact overview; pass `--include-contents` to embed truncated file
bodies when needed.

```bash
python -m zscripts tree --project-root sample_project --output /tmp/tree.txt --include-contents
```
This is useful when you need a contextual code review bundle or want to capture
changes across multiple stacks in a single artifact. Pass `--dry-run` to emit
the planned tree directly to STDOUT without writing an output file.

## Verification Checklist

All static analysis and tests run locally with reproducible commands:

```bash
make fmt      # Format sources with Ruff
make lint     # Lint sources
make type     # Strict mypy type checks
make security # Bandit security scanner
make test     # Pytest suite (including property-based coverage)
```

`make check` executes the full pipeline in the recommended order.

To keep commits clean, install the bundled Git hooks:

```bash
pip install -r requirements.txt
pre-commit install
```

The hooks run Ruff (format + lint), mypy, pytest, and Bandit for every commit.

## Sample Project

The `sample_project/` directory replaces the previous Django-only example with a
neutral, multi-language workspace:

- `backend/service.py` – Simple Python service with a tiny in-memory model.
- `frontend/App.jsx` – React component mirroring the backend task list.
- `infra/pipeline.yaml` – CI workflow that demonstrates invoking the CLI inside
  a GitHub Actions job.
- `scripts/build.sh` – Shell entry point that would wire backend and frontend
  build steps together.

Running `python -m zscripts collect --types all --project-root sample_project`
illustrates how Zscripts walks the different stacks using the same command.

## Observability and SLO Notes

- **Structured logs:** The CLI and sample database manager emit structured
  `event=...` log lines with error identifiers (`CLI001`, `FS001`, `DB001`,
  etc.) that can be scraped into centralized logging backends.
- **Success rate SLO:** The CLI targets a 99% success rate across scheduled
  runs. Investigate logs containing `error_id=CLI` or `error_id=FS` to triage
  regressions. Re-run `make check` for deterministic reproduction.
- **Latency expectation:** Property-based tests and scanners complete in under
  60 seconds on a developer laptop. If `make check` exceeds that window,
  profile disk-heavy paths in `zscripts.utils` before the next release.

## Migrating from the Django Scripts

If you previously relied on `config.py` constants and Django-specific
terminology, you can reproduce the same behaviour with the new configuration and
CLI.

1. **Reuse the existing skip list** – Copy the `skip` array from
   `zscripts.config.json` into your project and append any app-specific
   directories. This mirrors the old `SKIP_DIRS` value.
2. **Carry over file type buckets** – The old `FILE_TYPES` dictionary mapped
   Django module names to log categories. You can paste those mappings directly
   into the `file_types` section so consolidated reports continue to separate
   `models.py`, `views.py`, etc.
3. **Generate logs** – To match the previous `python zscripts/all/app_all_types.py`
   invocation, run:

   ```bash
   python -m zscripts collect --types python_html --project-root path/to/your/project
   ```

   This walks every Django app directory and produces log files in the location
   defined by `collection_logs.python_html`.
4. **Capture single-file summaries** – The `consolidate` subcommand is a drop-in
   replacement for the legacy `single_*.py` scripts. For example:

   ```bash
   python -m zscripts consolidate --types python --project-root path/to/your/project
   ```

   writes to the same `capture_all_pyth.txt` path used by the earlier scripts.

Because the CLI reads JSON, you can keep multiple configuration files around for
different frameworks (e.g., `zscripts.config.django.json` vs.
`zscripts.config.node.json`) and swap between them with the `--config` flag.
