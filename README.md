# Zscripts

Zscripts is a framework-agnostic utility for aggregating source files into
navigable logs. The toolchain helps multi-stack teams surface Python, JavaScript,
TypeScript, CSS, shell scripts, infrastructure YAML, and other assets in a
consistent format so they can audit or ship documentation more quickly.

The repository ships with a configurable command line interface, templates for
regenerating this README, and a sample project that mixes backend, frontend, and
infrastructure code to highlight cross-stack coverage.

## Repository Layout

- **sample_project/** – Mixed-language reference project that demonstrates how
  the scanners traverse Python, JavaScript, shell, and YAML sources.
- **zscripts/** – Python package containing the CLI, configuration loader, and
  supporting utilities.
- **zscripts.config.json** – Default configuration file consumed by the CLI and
  helper modules.
- **README.md** – Autogenerated documentation (built from files within
  `zscripts/zreadme/`).

## Configuration

The runtime configuration now lives in a standalone JSON document instead of a
Python module. By default, `python -m zscripts` loads `zscripts.config.json` from
the repository root. The schema is intentionally simple so it can be tracked in
source control or generated dynamically:

```jsonc
{
  "skip": ["node_modules", "venv", "dist"],
  "file_types": {
    "models.py": "models_files",
    "views.py": "views_files"
  },
  "directories": {
    "log_root": "logs",
    "build": "build_files",
    "analysis": "analysis_logs",
    "consolidation": "consoli_files",
    "work": "logs_files"
  },
  "collection_logs": {
    "python": "logs_apps_pyth",
    "all": "logs_apps_all"
  },
  "single_targets": {
    "python": "capture_all_pyth.txt",
    "any": "capture_all.txt"
  }
}
```

Every path is resolved relative to the `zscripts/` package directory, so the
example above stores aggregated logs under `zscripts/logs/`. You can provide a
custom configuration file via the `--config` flag on any CLI command. The module
`zscripts.config` exposes helpers (`load_config`, `get_config`, and constants such
as `LOG_DIR`) for scripts that want to introspect the parsed settings.

## CLI Workflow

The CLI bundles the most common automation routines under `python -m zscripts`.
Each command respects the configuration file described above.

```text
usage: python -m zscripts [-h] [--config CONFIG] [--project-root PROJECT_ROOT] {collect,consolidate,tree} ...
```

### `collect`
Generate per-directory logs for one or more stacks. The command accepts a
comma-separated list of stacks (`python`, `html`, `css`, `js`, `python_html`, or
`all`).

```bash
python -m zscripts collect --types python,js --project-root sample_project
```

Logs are written to the directories declared in `collection_logs`.

### `consolidate`
Create a single file that merges all sources for the requested stack.

```bash
python -m zscripts consolidate --types python --output /tmp/project-python.txt
```

When no output file is supplied, the command falls back to the
`single_targets` configuration entry.

### `tree`
Snapshot the repository structure and inline the content of tracked files.

```bash
python -m zscripts tree --project-root sample_project --output /tmp/tree.txt
```
- **SKIP_DIRS:** List of directories to skip during file operations.
- **DEFAULT_FILE_GROUPS:** Mapping of log categories to filename, glob, or extension patterns, merged with optional overrides from `zscripts.config.yaml` at the project root.
- **get_file_group_resolver():** Helper that resolves configured patterns for fast lookups throughout the logging utilities.
- **Directories:** Various directories defined for logging and output purposes.

This is useful when you need a contextual code review bundle or want to capture
changes across multiple stacks in a single artifact.

## Sample Project

The `sample_project/` directory replaces the previous Django-only example with a
neutral, multi-language workspace:

- `backend/service.py` – Simple Python service with a tiny in-memory model.
- `frontend/App.jsx` – React component mirroring the backend task list.
- `infra/pipeline.yaml` – CI workflow that demonstrates invoking the CLI inside
  a GitHub Actions job.
- `scripts/build.sh` – Shell entry point that would wire backend and frontend
  build steps together.

Running `python -m zscripts collect --types all --project-root sample_project`
illustrates how Zscripts walks the different stacks using the same command.

## Migrating from the Django Scripts

If you previously relied on `config.py` constants and Django-specific
terminology, you can reproduce the same behaviour with the new configuration and
CLI.

1. **Reuse the existing skip list** – Copy the `skip` array from
   `zscripts.config.json` into your project and append any app-specific
   directories. This mirrors the old `SKIP_DIRS` value.
2. **Carry over file type buckets** – The old `FILE_TYPES` dictionary mapped
   Django module names to log categories. You can paste those mappings directly
   into the `file_types` section so consolidated reports continue to separate
   `models.py`, `views.py`, etc.
3. **Generate logs** – To match the previous `python zscripts/all/app_all_types.py`
   invocation, run:

   ```bash
   python -m zscripts collect --types python_html --project-root path/to/your/project
   ```

   This walks every Django app directory and produces log files in the location
   defined by `collection_logs.python_html`.
4. **Capture single-file summaries** – The `consolidate` subcommand is a drop-in
   replacement for the legacy `single_*.py` scripts. For example:

   ```bash
   python -m zscripts consolidate --types python --project-root path/to/your/project
   ```

   writes to the same `capture_all_pyth.txt` path used by the earlier scripts.

Because the CLI reads JSON, you can keep multiple configuration files around for
different frameworks (e.g., `zscripts.config.django.json` vs.
`zscripts.config.node.json`) and swap between them with the `--config` flag.
